\documentclass[format=manuscript]{acmart}

\usepackage{amssymb}
\usepackage{textcomp}

\begin{document}
\title{Protocol Synthesis - Brainstorming}

%% Preprocessing
% To remove citation information below abstract
\settopmatter{printacmref=false}
% To remove DOI information
\makeatletter
\renewcommand\@formatdoi[1]{\ignorespaces}
\makeatother
% To remove copyright information
\setcopyright{none}

\maketitle

%% Commands

\newcommand{\valOf}[1]{\ensuremath{#1.\texttt{v}}}
\newcommand{\stOf}[1]{\ensuremath{#1.\texttt{st}}}
\newcommand{\objGetRq}[1]{\ensuremath{#1.\texttt{getRq()}}}
\newcommand{\objGetRs}[2]{\ensuremath{#1:\texttt{getRs(}#2\texttt{)}}}
\newcommand{\objSetRq}[2]{\ensuremath{#1.\texttt{setRq(}#2\texttt{)}}}
\newcommand{\objSetRs}[1]{\ensuremath{#1:\texttt{setRs()}}}

\newcommand{\refInv}[1]{[Invariant~\ref{#1}]}
\newcommand{\refTrs}[1]{[Transition~\ref{#1}]}
\newcommand{\refFig}[1]{[Figure~\ref{#1}]}

\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}

\section{User Inputs}

In order to synthesize a protocol, a user should provide following information:

\begin{itemize}
\item A topology among objects, including the number of channels between any two
  objects.
\item Type of the whole state (and corresponding initial value)
\item State invariants ($\textsf{State} \to \textsf{Prop}$)
\item State transitions (by external interfaces) ($\textsf{State} \to
  \textsf{State} \to \textsf{Prop}$)
\end{itemize}

Our running example is a two-level cache structure with a parent and two
children, using an MSI protocol. Each object $O$ has just a single value
\valOf{O} and its status \stOf{O}.

\paragraph{Example} User inputs for our running example is as follows:
\begin{itemize}
\item Topology
  \begin{itemize}
  \item Objects: $P$, $C_1$, and $C_2$
  \item Channels: ...
  \end{itemize}
\item State type: $P(0, S), C_1(0, S), C_2(0, S)$.
\item State invariants:
  \begin{align}
    \stOf{C_1} = M \to \stOf{C_2} = I \label{inv1} \\
    \stOf{C_2} = M \to \stOf{C_1} = I \label{inv2} \\
    \stOf{P} \geq \texttt{max}(\stOf{C_1}, \stOf{C_2}) \label{inv3}
  \end{align}
\item State transitions:
  \begin{eqnarray}
    \{ \stOf{C_i} \geq S \}
    & \objGetRq{C_i}
    & \{ \objGetRs{C_i}{\valOf{C_i}}, \top \} \label{trs1} \\
    \{ \stOf{C_i} = M \}
    & \objSetRq{C_i}{v}
    & \{ \objSetRs{C_i}, \valOf{C_i} = v \} \label{trs2}
  \end{eqnarray}
\end{itemize}

\section{Non-executable Protocol by Predicated Messages}

We give some examples to see how predicated messages are generated and induce
state transitions.

\subsection{Transactions}

Before we discuss various cases, we define some notions about transaction.

\begin{definition}[Transaction]
  A transaction is a pair, consisting of a request and a response. It starts
  when an object \emph{passes a predicated message} (requests) to another
  object. It ends when the object gets the response, indicating that the
  predicate holds now. Certainly a request happens earlier than the response in
  terms of timeline.
\end{definition}

\begin{definition}[Transaction Predicate]
  A transaction predicate is a predicate that an object requested to
  others. When an object requests, it is holding the request to see whether it
  is fine to process some other requests/responses before it gets the response.
\end{definition}

\begin{definition}
  Two transactions are serial if a response of one transaction happens earlier
  than the request of the other. It not, they are concurrent (interleaving).
\end{definition}

\subsection{Serial Cases}\label{serial-cases}

Now let's take a look at some simple cases first, where interleavings do not
happen.

\paragraph{Case 1}
When a precondition for a request holds, then corresponding state transition
happens immediately; \eg{}, for a request $\objGetRq{C_1}$ with an initial
state:

\begin{enumerate}
\item It requires $\stOf{C_1} \geq S$ by \refTrs{trs2}.
\item The precondition already holds since $\stOf{C_1} = S$, thus $C_1$
  immediately responds with
\end{enumerate}

\paragraph{Case 2}
If a precondition does not hold, then an object makes additional requests to
other objects. Right after it gets a corresponding response, a state transition
happens. Here is a scenario for a request $\objSetRq{C_1}{47}$:

\begin{enumerate}
\item It requires $\stOf{C_1} = M$ by \refTrs{trs1}.
\item We need $\stOf{C_2} = I$ by \refInv{inv1} and $\stOf{P} = M$ by
  \refInv{inv3}.
\item A predicated message is generated: $\{ C_1: \stOf{C_1} = M; C_2:
  \stOf{C_2} = I; P: \stOf{P} = M \}$.
\item $C_1$ holds this message as a transaction predicate to claim it is during
  a certain transaction. Now it requests a new predicated message to $P$ (by the
  topology), where to new message does not contain predicates about $C_1$.
  Hence the new message is: $\{ C_2: \stOf{C_2} = I; P: \stOf{P} = M \}$.
\item $P$ receives the message from $C_1$. It sees that there is a requirement
  for $C_2$, which implies an additional request is needed. Thus, it holds the
  predicate, generates a new message $\{ C_2: \stOf{C_2} = I \}$, and sends it
  to $C_2$.
\item $C_2$ receives the message from $P$. It changes its status to $I$
  immediately, and responds to $P$.
\item $P$ receives the response. Looking at its transaction predicate, now it
  finds out the only obligation is about itself. It changes its status to $M$,
  and responds to $C_1$.
\item $C_1$ receives the response. It changes its status to $M$. Since the
  precondition holds, finally it executes $\objSetRq{C_1}{47}$.
\end{enumerate}

\subsection{Concurrent Cases}\label{concurrent-cases}

In this section, we study how predicated messages and transaction notions help
us find correct interleavings. One of most important reasonings about
transactions is whether to allow interleavings among them. It is directly
related to the correctness of a protocol, since the specification is usually
serial. If we are too strict to allow interleavings, it might be easy to prove
refinements, but implementations may have deadlocks. Conversely, if we are too
loose to allow interleavings, implementations would not be correct.

Let's start with a very naive approach: whenever an object holds a predicate --
meaning that it requested something and is waiting for the response -- it
refuses to handle any other messages except the response.

\paragraph{Case 1 \& 2}\label{concurrent-case12}
When $C_1$ and $C_2$ request to set data at the same time, a problem arises.

\begin{enumerate}
\item $m_1 = \objSetRq{C_1}{47}$ is requested.
\item $m_2 = \objSetRq{C_2}{23}$ is requested.
\item By $m_1$, a predicated message is generated: $\{ C_1: \stOf{C_1} = M; C_2:
  \stOf{C_2} = I; P: \stOf{P} = M \}$. This is held by $C_1$, and it requests to
  $P$ with $\{ C_2: \stOf{C_2} = I; P: \stOf{P} = M \}$.
\item By $m_2$, a predicated message is generated: $\{ C_1: \stOf{C_1} = I; C_2:
  \stOf{C_2} = M; P: \stOf{P} = M \}$. This is held by $C_2$, and it requests to
  $P$ with $\{ C_1: \stOf{C_1} = I; P: \stOf{P} = M \}$.
\item $P$ (nondeterministically) decides to handle a request by $C_1$ first. As
  seen in serial cases, it holds $\{ C_2: \stOf{C_2} = I; P: \stOf{P} = M \}$
  and requests $\{ C_2: \stOf{C_2} = I; \}$ to $C_2$.
\end{enumerate}

Below figure describes the status between $P$ and $C_2$ after (5). Since both
$P$ and $C_2$ hold predicates, they refuse to handle any other messages -- a
deadlock happens.

\begin{figure}[h]
  \begin{math}
    \begin{array}{c}
      P \{ C_2: \stOf{C_2} = I; P: \stOf{P} = M \} \\
      \{ C_1: \stOf{C_1} = I; P: \stOf{P} = M \} \uparrow
      \downarrow \{ C_2: \stOf{C_2} = I; \} \\
      C_2 \{ C_1: \stOf{C_1} = I; C_2: \stOf{C_2} = M; P: \stOf{P} = M \}
    \end{array}
  \end{math}
  \caption{$P$ and $C_2$ both handling transactions}
\end{figure}

How can we solve this deadlock case? Note that in this case whichever message is
chosen, we can design a correct protocol. But a deadlock issue still remains
when we choose to handle the message from $C_2$. After $P$ handling $\{ C_1:
\stOf{C_1} = I; P: \stOf{P} = M \}$, $P$ should send $\{ C_1: \stOf{C_1} = I \}$
to $C_1$. However, since $C_1$ is holding $\{ C_1: \stOf{C_1} = M; C_2:
\stOf{C_2} = I; P: \stOf{P} = M \}$, it refuses to handle the message similar to
$C_2$. Thus, in order to avoid deadlocks, we should choose $C_2$ to handle the
message from $P$.

We will discuss various deadlock cases in later sections (this is certainly
related to correctness of synthesis).

Let's continue the scenario after (5):

\begin{enumerate}
  \setcounter{enumi}{5}
\item $C_2$ handles $\{ C_2: \stOf{C_2} = I \}$. It changes its status to $I$
  immediately, and responds to $P$.
\item $P$ receives the response. Looking at its transaction predicate, now it
  finds out the only obligation is about itself. It changes its status to $M$,
  and responds to $C_1$.
\item (\emph{Before $C_1$ handles the response above}) Now $P$ does not have any
  transaction predicates. Thus it handles the message from $C_2$, holds $\{ C_1:
  \stOf{C_1} = I; P: \stOf{P} = M \}$, and requests $\{ C_1: \stOf{C_1} = I; \}$
  to $C_1$.
\item $C_1$ handles the response from (7) first; it changes its status to $M$,
  and executes $\objSetRq{C_1}{47}$.
\item Next $C_1$ handles the request from (8). It changes its status to $I$
  immediately, and responds to $P$.
\item $P$ receives the response (from $C_1$). Looking at its transaction
  predicate, now it finds out the only obligation is about itself. It changes
  its status to $M$, and responds to $C_2$.
\item $C_2$ handles the response; it changes its status to $M$, and executes
  $\objSetRq{C_2}{23}$.
\end{enumerate}

There are a number of caveats from (6) to (12):

\begin{itemize}
\item At (7), we assume that two separate channels exist from $C_2$ to $P$ --
  one for requests and the other for responses. It implies that \emph{a topology
    given by a user affects deadlocks/livelocks}.
\item By (7) and (8), there are two messages from $P$ to $C_1$. At (9), $C_1$
  choose the response to handle, which came earlier than the request from (8).
  If a user gave the topology with two separate channels from $P$ to $C_1$, it
  is possible to design an incorrect protocols (when $C_1$ decides to handle the
  message from (8) first). It implies that \emph{a topology given by a user also
    affects the correctness of the protocol}.
\end{itemize}

\subsection{Safe Interleavings}

TBD.

\section{Synthesis with Predicated Messages}

TBD.

\section{Proving the Correctness of Synthesis}

TBD.

\end{document}
