\documentclass[format=manuscript]{acmart}

\usepackage{amssymb}
\usepackage{textcomp}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{tikz} \usetikzlibrary{cd}
\usepackage{color}

\begin{document}
\title{Synthesizing Protocols for Message-Passing Systems}
\subtitle{A brief note about syntheses and proofs}

%% Preprocessing
% To remove citation information below abstract
\settopmatter{printacmref=false}
% To remove DOI information
\makeatletter
\renewcommand\@formatdoi[1]{\ignorespaces}
\makeatother
% To remove copyright information
\setcopyright{none}

\maketitle

%% Commands

\newcommand{\todo}[1]{\textcolor{red}{TODO}: #1}

\newcommand{\valOf}[1]{\ensuremath{#1.\texttt{v}}}
\newcommand{\stOf}[1]{\ensuremath{#1.\texttt{st}}}
\newcommand{\trsOf}[1]{\ensuremath{#1.\texttt{trs}}}
\newcommand{\trsYes}{\ensuremath{\top}}
\newcommand{\trsNo}{\ensuremath{\bot}}

\newcommand{\objGetRq}[1]{\ensuremath{#1.\texttt{getRq()}}}
\newcommand{\objGetRs}[2]{\ensuremath{#1:\texttt{getRs(}#2\texttt{)}}}
\newcommand{\objSetRq}[2]{\ensuremath{#1.\texttt{setRq(}#2\texttt{)}}}
\newcommand{\objSetRs}[1]{\ensuremath{#1:\texttt{setRs()}}}

\newcommand{\intSetRq}[2]{\ensuremath{#1 \leadsto #2.\texttt{setRq()}}}
\newcommand{\intSetRs}[2]{\ensuremath{#1 \leadsto #2.\texttt{setRs()}}}
\newcommand{\intInvRq}[2]{\ensuremath{#1 \leadsto #2.\texttt{invRq()}}}
\newcommand{\intInvRs}[2]{\ensuremath{#1 \leadsto #2.\texttt{invRs()}}}

\newcommand{\msgrule}[4]{\ensuremath{#1\vdash \{ #2 \} \xrightarrow{#3} \{ #4 \}}}

\newcommand{\refSec}[1]{[Section~\ref{#1}]}
\newcommand{\refInv}[1]{[Invariant~\ref{#1}]}
\newcommand{\refTrs}[1]{[Transition~\ref{#1}]}
\newcommand{\refFig}[1]{[Figure~\ref{#1}]}

\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}

\section{User Inputs}

In order to synthesize a protocol, a user should provide $(\mathcal{I}_0,
\mathcal{S}, R_0)$:

\begin{itemize}
\item $\mathcal{I}_0$ is an initial system, consisting of
  \begin{enumerate}
  \item A topology among objects, including the number of channels between any
    two objects.
  \item Type of the whole state (and corresponding initial value)
  \item \emph{No state transitions}!
  \end{enumerate}
\item $\mathcal{S}$ is the target specification system.
\item $R_0: \textsf{State} \to \textsf{State} \to \textsf{Prop}$ is a simulation
  relation connecting \emph{only the stable states of implementations} to their
  corresponding states of the spec. In other words, $R_0$ does not include
  relations about \emph{transient states} in implementations. We will eventually
  prove that during a synthesis process $R_0$ always holds for each stable
  state, while the relation may not hold for transient states.
\end{itemize}

\paragraph{Inputs for the Running Example}
Our running example is a two-level cache structure with a parent and two
children, using an MSI protocol. Each object $O$ has a single value \valOf{O}
and its status \stOf{O}.

User inputs are as follows:

\begin{itemize}
\item For $\mathcal{I}_0$:
  \begin{enumerate}
  \item Topology
    \begin{itemize}
    \item Objects: $P$, $C_1$, and $C_2$
    \item Channels: $\{ i = 1,2\ |\ e_i \rightarrow C_i, C_i \rightarrow e_i,
      C_i \xrightarrow{\texttt{rq}} P, C_i \xrightarrow{\texttt{rs}} P, P
      \rightarrow C_i \}$ (``$e_i$'' indicates an external interface)
    \end{itemize}
  \item State type and initial values
    \begin{itemize}
    \item $P, C_1, C_2: \{ \texttt{v}: \mathbb{N};\ \texttt{st}: \{M, S, I\} \}$.
    \item Initial values: $P(0, S), C_1(0, S), C_2(0, S)$.
    \end{itemize}
  \end{enumerate}
\item For $\mathcal{S}$:
  \begin{enumerate}
  \item Topology
    \begin{itemize}
    \item Objects: $S$
    \item Channels: $\{ i = 1,2\ |\ e_i \rightarrow S, S \rightarrow e_i \}$.
    \end{itemize}
  \item State type and initial values
    \begin{itemize}
    \item $S: \{ \texttt{v}: \mathbb{N} \}$.
    \item Initial values: $S(0)$.
    \end{itemize}
  \item State transitions:
    \begin{eqnarray}
      \msgrule{\objGetRq{S}}{\top}{\objGetRs{S}{\valOf{S}}}{\top} \label{trs3} \\
      \msgrule{\objSetRq{S}{v}}{\top}{\objSetRs{S}}{\valOf{S} = v} \label{trs4}
    \end{eqnarray}
  \end{enumerate}
\item For $R_0$:
  \begin{itemize}
  \item $\{ v\ |\ (\{ P(\cdot, M); C_1(v, M); C_2(\cdot, I) \},\ S(v)) \} \subset R_0$
  \item $\{ v\ |\ (\{ P(\cdot, M); C_1(\cdot, I); C_2(v, M) \},\ S(v)) \} \subset R_0$
  \item $\{ v\ |\ (\{ P(\cdot, S); C_1(v, S); C_2(v, S) \},\ S(v)) \} \subset R_0$
  \end{itemize}
\end{itemize}

\section{Non-executable Protocol Design by Predicated Messages}

\subsection{Transactions}

\begin{definition}[Transaction]
  A transaction is a pair, consisting of a request and a response. It starts
  when an object \emph{passes a predicated message} (requests) to another
  object. It ends when the object gets the response, indicating that the
  predicate should be satisfiable now. Certainly a request happens earlier than
  the response in terms of timeline.
\end{definition}

\begin{definition}[Transaction Predicate]
  A transaction predicate is a predicate that an object requested to
  others. When an object requests, it holds the request (1) to check the request
  is finally handled by all related other objects so it can respond back, and
  (2) to ensure whether it is safe to process some other requests/responses
  \emph{before} it receives the response (to ensure safe interleavings).
\end{definition}

\begin{definition}
  Two transactions are serial if a response of one transaction happens earlier
  than the request of the other. It not, they are concurrent (interleaving).
\end{definition}

\subsection{Serial Cases}\label{serial-cases}

Let's take a look at some simple cases first, where interleavings do not happen.

\paragraph{Case 1}
If a precondition for a request holds, then corresponding state transition
happens immediately; \eg{}, for a request $\objGetRq{C_1}$ with an initial
state:

\begin{enumerate}
\item Initially (currently) $\stOf{C_1} = S$, and we assume that the whole state
  is stable now. Based on this assumption, we infer the whole state as detailed
  as possible. By the definition of $R_0$, we are currently on $\{ P(\cdot, S);
  C_1(v, S); C_2(v, S) \}\ R_0\ S(v)$ for some $v$.
\item Now let's draw a commutative diagram (about $R_0$) for the transition:
  \begin{figure}[h]
    \begin{tikzcd}[column sep=huge]
      \{ P(\cdot, S); C_1(v, S); C_2(v, S) \}
      \arrow[r, "\objGetRs{S}{v}"] \arrow[d, dash, "R_0"] &
      \{ P(?, ?); C_1(?, ?); C_2(?, ?) \} \arrow[d, dash, "R_0"] \\
      S(v) \arrow[r, "\objGetRs{S}{v}"] &
      S(v)
    \end{tikzcd}
    \caption{A commutative diagram for $\objGetRq{C_1}$}
    \label{fig:comm-diagram-getrq}
  \end{figure}
  
  Our mission here is to (automatically) find entries of $\{ P(?, ?); C_1(?, ?);
  C_2(?, ?) \}$ (\emph{note}: when we define $R_0$ as an inductive relation,
  hopefully Coq's $\texttt{eauto}$ would find the answer).
\item In this case, we can simply fill $\{ P(\cdot, S); C_1(v, S); C_2(v, S) \}$
  to satisfy the commutativity. There is no need for additional requests to
  others, so we give the immediate response.
\end{enumerate}

\paragraph{Case 2}
If a precondition does not hold, then the object has to make additional requests
to other objects. Right after it receives corresponding responses, a state
transition happens. Below is a scenario for a request $\objSetRq{C_1}{47}$:

\begin{enumerate}
\item As we did in Case 1, given the current state $\stOf{C_1} = S$, we infer
  the whole state using $R_0$. We get $\{ P(?, S); C_1(v, S); C_2(v, S) \}$ for
  some $v$.
\item Below is the diagram for the case:
  \begin{figure}[h]
    \begin{tikzcd}[column sep=huge]
      \{ P(\cdot, S); C_1(v, S); C_2(v, S) \}
      \arrow[r, Rightarrow, "\objSetRs{S}"] \arrow[d, dash, "R_0"] &
      \{ P(?, ?); C_1(?, ?); C_2(?, ?) \} \arrow[d, dash, "R_0"] \\
      S(v) \arrow[r, "\objSetRs{S}"] &
      S(47)
    \end{tikzcd}
    \caption{A commutative diagram for $\objSetRq{C_1}{47}$}
    \label{fig:comm-diagram-setrq}
  \end{figure}
\item While there are a number of possible instances to fill $\{ P(?, ?); C_1(?,
  ?); C_2(?, ?) \}$, let's assume for now we automatically chose $\{ P(\cdot,
  M); C_1(47, M); C_2(\cdot, I) \}$. We will discuss this in later sections.
\item Now a predicated message is generated: $\{ C_1: \stOf{C_1} = M \wedge
  \valOf{C_1} = 47; C_2: \stOf{C_2} = I; P: \stOf{P} = M \}$.
\item $C_1$ holds this message \emph{as a transaction predicate}. Now it
  requests a new predicated message to $P$ (by the topology), where the new
  message does not contain predicates about $C_1$. Hence the new message is: $\{
  C_2: \stOf{C_2} = I; P: \stOf{P} = M \}$.
\item $P$ receives the message from $C_1$. It finds that there is a requirement
  for $C_2$, which implies an additional request is needed. Thus, it holds the
  message (as a transaction predicate), generates a new message $\{ C_2:
  \stOf{C_2} = I \}$, and sends it to $C_2$.
\item $C_2$ receives the message from $P$. Since there are no other obligations
  for other objects, it immediately changes its status to $I$ and responds to
  $P$.
\item $P$ receives the response. Looking at its transaction predicate, now it
  finds out the only remaining obligation is about itself. It changes its status
  to $M$, and responds to $C_1$.
\item $C_1$ receives the response. Finally it makes the state transition,
  changing its status to $M$ and its value to $47$, with a label
  $\objSetRq{C_1}{47}$.
\end{enumerate}

\subsection{Concurrent Cases}\label{concurrent-cases}

We now explore how predicated messages help us ensure safe interleavings. The
only question we should answer is when it is fine to allow interleavings. It is
directly related to the correctness of a protocol, since the specification is
serial.

If a protocol is too strict to allow interleavings, it might be easy to prove
refinements, but implementations may have \emph{deadlocks}. Conversely, if a
protocol is too loose, an implementation would not be correct.

Let's start with a very naive approach: whenever an object holds a predicate --
meaning that it requested something and is waiting for the response -- it
refuses to handle any other messages except the response.

A problem occurs when $C_1$ and $C_2$ request to set data at the same time.

\begin{enumerate}
\item $m_1 = \objSetRq{C_1}{47}$ is requested.
\item $m_2 = \objSetRq{C_2}{23}$ is requested.
\item By $m_1$, a predicated message is generated: $\{ C_1: \stOf{C_1} = M; C_2:
  \stOf{C_2} = I; P: \stOf{P} = M \}$. This is held by $C_1$, and it requests to
  $P$ with $\{ C_2: \stOf{C_2} = I; P: \stOf{P} = M \}$.
\item By $m_2$, a predicated message is generated: $\{ C_1: \stOf{C_1} = I; C_2:
  \stOf{C_2} = M; P: \stOf{P} = M \}$. This is held by $C_2$, and it requests to
  $P$ with $\{ C_1: \stOf{C_1} = I; P: \stOf{P} = M \}$.
\item $P$ (nondeterministically) decides to handle a request by $C_1$ first. As
  seen in serial cases, it holds $\{ C_2: \stOf{C_2} = I; P: \stOf{P} = M \}$
  and requests $\{ C_2: \stOf{C_2} = I; \}$ to $C_2$.
\end{enumerate}

\refFig{fig:deadlock} describes the status between $P$ and $C_2$ after
(5). Since both $P$ and $C_2$ hold predicates, they refuse to handle any other
messages -- a deadlock happens.

\begin{figure}[h]
  \begin{math}
    \begin{array}{c}
      P \{ C_2: \stOf{C_2} = I; P: \stOf{P} = M \} \\
      \{ C_1: \stOf{C_1} = I; P: \stOf{P} = M \} \uparrow
      \downarrow \{ C_2: \stOf{C_2} = I; \} \\
      C_2 \{ C_1: \stOf{C_1} = I; C_2: \stOf{C_2} = M; P: \stOf{P} = M \}
    \end{array}
  \end{math}
  \caption{$P$ and $C_2$ both handling transactions}
  \label{fig:deadlock}
\end{figure}

How can we solve this deadlock case? First note that in this case whichever
message is chosen, we can design a correct protocol. But a deadlock issue still
remains when we choose to handle the message from $C_2$. After $P$ handling $\{
C_1: \stOf{C_1} = I; P: \stOf{P} = M \}$, $P$ should send $\{ C_1: \stOf{C_1} =
I \}$ to $C_1$. However, since $C_1$ is holding $\{ C_1: \stOf{C_1} = M; C_2:
\stOf{C_2} = I; P: \stOf{P} = M \}$, it refuses to handle the message similar to
$C_2$. Thus, in order to avoid deadlocks, we should choose $C_2$ to handle the
message from $P$.

We will discuss various deadlock cases in later sections (this is certainly
related to correctness of synthesis).

Let's continue the scenario after (5):

\begin{enumerate}
  \setcounter{enumi}{5}
\item $C_2$ handles $\{ C_2: \stOf{C_2} = I \}$. It changes its status to $I$
  immediately, and responds to $P$.
\item $P$ receives the response. Looking at its transaction predicate, now it
  finds out the only obligation is about itself. It changes its status to $M$,
  and responds to $C_1$.
\item (\emph{Before $C_1$ handles the response above}) Now $P$ does not have any
  transaction predicates. Thus it handles the message from $C_2$, holds $\{ C_1:
  \stOf{C_1} = I; P: \stOf{P} = M \}$, and requests $\{ C_1: \stOf{C_1} = I; \}$
  to $C_1$.
\item $C_1$ handles the response from (7) first; it changes its status to $M$,
  and executes $\objSetRq{C_1}{47}$.
\item Next $C_1$ handles the request from (8). It changes its status to $I$
  immediately, and responds to $P$.
\item $P$ receives the response (from $C_1$). Looking at its transaction
  predicate, now it finds out the only obligation is about itself. It changes
  its status to $M$, and responds to $C_2$.
\item $C_2$ handles the response; it changes its status to $M$, and executes
  $\objSetRq{C_2}{23}$.
\end{enumerate}

There are a number of caveats from (6) to (12):

\begin{itemize}
\item At (7), we assume that two separate channels exist from $C_2$ to $P$ --
  one for requests and the other for responses. It means that \emph{a topology
    given by a user may cause deadlocks/livelocks}.
\item By (7) and (8), there are two messages from $P$ to $C_1$. At (9), $C_1$
  choose the response to handle, which came earlier than the request from (8).
  If a user gave the topology with two separate channels from $P$ to $C_1$, it
  is possible to design an incorrect protocols (when $C_1$ decides to handle the
  message from (8) first). It means that \emph{a topology given by a user may
    also cause an incorrect protocol}.
\end{itemize}

To emphasize the fact again: a user should design a topology carefully both for
correctness and liveness.

\section{Synthesis with Predicated Messages}

\subsection{Requests and Responses}

\begin{itemize}
\item A request message is synthesized \emph{when an object passes a predicated
  message to another object}.
\item A response message -- to the object that originally requested -- is
  synthesized \emph{when an object finds that its transaction predicate is
    satisfied}.
\end{itemize}

According to the definitions of requests and responses, an object state changes
\emph{only when} it sends a response. Forwarding requests does not involve any
state changes.

\subsection{Safe Interleavings = Correct Preconditions for Rules}

As seen in \refFig{fig:deadlock}, for the sake of safe interleavings, an object
sometimes refuses to handle messages. During synthesis, transaction predicates
are turned into \emph{preconditions}: each message handler (rule) has its own
precondition -- whether to execute the rule or not -- where its transaction
predicate is given as an argument.

One of very strong preconditions would say that any rules cannot be executed
when the target object holds a predicate. However, as discussed in
\refSec{concurrent-cases}, a synthesized protocol would be correct but may cause
deadlocks.

\subsection{A Case Study}

Here we synthesize a protocol for our running example. Let's first synthesize
message handlers (rules) not worrying about interleavings.

\paragraph{Starting by Looking at Stable States}

According to the definition of $R_0$, the whole state always belongs to
following three cases:

\begin{enumerate}
\item $\{ v\ |\ (\{ P(\cdot, M); C_1(v, M); C_2(\cdot, I) \},\ S(v)) \}$
\item $\{ v\ |\ (\{ P(\cdot, M); C_1(\cdot, I); C_2(v, M) \},\ S(v)) \}$
\item $\{ v\ |\ (\{ P(\cdot, S); C_1(v, S); C_2(v, S) \},\ S(v)) \}$
\end{enumerate}

For each case, we will synthesize state transitions triggered by external
requests.

\todo{describe}

\iffalse %% Below code fragment is commented out

\begin{center}
  \msgrule{\objSetRq{C_i}{v}}{\stOf{C_i} = M}{\objSetRs{C_i}}{\valOf{C_i} = v}
\end{center}

By looking at the rule for \objGetRq{C_1}, we can deterministically know we need
an additional rule when $\stOf{C_1} < S$. In this case, a predicated message $\{
\stOf{C_1} = S; \stOf{C_2} \neq M; \stOf{P} \geq S \}$ is generated (why?). By
the topology, it is sent to $P$. Similar reasoning applies to $C_2$ by symmetry.
For $\{i, j\} = \{1, 2\}, i \neq j$:

\begin{center}
  \msgrule{\objSetRq{C_i}{v}}{\stOf{C_i} \neq M}{\intSetRq{C_i}{P}}{\top}, where
  \intSetRq{C_i}{P} is mapped to $\{ \stOf{C_j} = I; \stOf{P} = M \}$.
\end{center}

Following the topology, it is now time to synthesize rules for $P$; we have to
synthesize two rules corresponding to \intSetRq{C_i}{P}, which are generated
while synthesizing \objSetRq{C_i}{v} above.

\begin{center}
  \msgrule{\intSetRq{C_i}{P}}{\top}{\intInvRq{P}{C_j}}{\top}, where
  \intInvRq{P}{C_j} is mapped to $\{ \stOf{C_j} = I \}$.
\end{center}

Lastly, (request) rules for $C_j$ are synthesized as below.

\begin{center}
  \msgrule{\intInvRq{P}{C_j}}{\top}{\intInvRs{C_j}{P}}{\stOf{C_j} = I}
\end{center}

Synthesizing response rules is quite trivial; when an object receives a
response, it checks its current transaction predicate and decides whether to
forward the response or not. Basically, an object forwards a response when it
confirms all related transaction predicates are satisfied.

\begin{center}
  \msgrule{\intInvRs{C_j}{P}}{\top}{\intSetRs{P}{C_i}}{\stOf{P} = M}
\end{center}

\begin{center}
  \msgrule{\intSetRs{P}{C_i}}{\top}{\objSetRs{C_i}}{\stOf{C_i} = M \wedge
    \valOf{C_i} = v}
\end{center}

Note that $v$ in \intSetRs{P}{C_i} comes from the original request; we should
hold the value in the object ($C_i$) until it receives the response.

\refFig{fig:synthesized-rules-naive} is the synthesized rules, without
considering safe interleavings:

\begin{figure}[h]
  \begin{eqnarray*}
    C_i\ \textrm{handles}: &
    \msgrule{\objSetRq{C_i}{v}}{\stOf{C_i} = M}{\objSetRs{C_i}}{\valOf{C_i} = v} \\
    & \msgrule{\objSetRq{C_i}{v}}{\stOf{C_i} \neq M}{\intSetRq{C_i}{P}}{\top} \\
    & \msgrule{\intInvRq{P}{C_i}}{\top}{\intInvRs{C_i}{P}}{\stOf{C_i} = I} \\
    & \msgrule{\intSetRs{P}{C_i}}{\top}{\objSetRs{C_i}}{\stOf{C_i} = M \wedge \valOf{C_i} = v} \\
    P\ \textrm{handles}: &
    \msgrule{\intInvRs{C_j}{P}}{\top}{\intSetRs{P}{C_i}}{\stOf{P} = M} \\
    & \msgrule{\intSetRq{C_i}{P}}{\top}{\intInvRq{P}{C_j}}{\top} \\
  \end{eqnarray*}
  \caption{Synthesized rules without considering safe interleavings}
  \label{fig:synthesized-rules-naive}
\end{figure}

\subsection{Synthesizing Preconditions}

Based on the rules described in \refFig{fig:synthesized-rules-naive}, let's put
some preconditions for safe interleavings.

\begin{figure}[h]
  \begin{eqnarray*}
    C_i\ \textrm{handles}: &
    \msgrule{\objSetRq{C_i}{v}}{\underline{\trsOf{C_i} = \trsNo{}} \wedge \stOf{C_i} = M}{\objSetRs{C_i}}{\valOf{C_i} = v} \\
    & \msgrule{\objSetRq{C_i}{v}}{\underline{\trsOf{C_i} = \trsNo{}} \wedge \stOf{C_i} \neq M}{\intSetRq{C_i}{P}}{\underline{\trsOf{C_i} = \trsYes{}}} \\
    & \msgrule{\intInvRq{P}{C_i}}{\top}{\intInvRs{C_i}{P}}{\stOf{C_i} = I} \\
    & \msgrule{\intSetRs{P}{C_i}}{\top}{\objSetRs{C_i}}{\underline{\trsOf{C_i} = \trsNo{}} \wedge \stOf{C_i} = M \wedge \valOf{C_i} = v} \\
    P\ \textrm{handles}: &
    \msgrule{\intInvRs{C_j}{P}}{\top}{\intSetRs{P}{C_i}}{\underline{\trsOf{P} = \trsNo{}} \wedge \stOf{P} = M} \\
    & \msgrule{\intSetRq{C_i}{P}}{\underline{\trsOf{P} = \trsNo{}}}{\intInvRq{P}{C_j}}{\underline{\trsOf{P} = \trsYes{}}} \\
  \end{eqnarray*}
  \caption{Synthesized rules}
  \label{fig:synthesized-rules}
\end{figure}

\refFig{fig:synthesized-rules} shows final synthesized rules. \trsOf{\cdot} is
\trsYes{} if the target object holds a predicate. Remind that the precondition
of \intInvRq{P}{C_i} does not have a predicate about \trsOf{C_i}; if the object
has it, a deadlock occurs.

\fi %% The comment ends here.

\section{Proving the Correctness of Synthesis}

\subsection{Proof Sketch}

\begin{enumerate}
\item Initial correctness: we begin by proving the correctness of
  $\mathcal{I}_0$. Formally, we prove $\mathcal{I}_0 \sqsubseteq
  \mathcal{S}$. It is immediately proven when we show that $R$ is a
  \emph{simulation} between $\mathcal{I}_0$ and $\mathcal{S}$. Note that we
  indeed expect a user provides $R$ enough to prove the correctness. Moreover,
  even with the initial system $\mathcal{I}_0$, the correctness should be
  provable, while the liveness might not be provable (no rules to proceed).
\item Preservation: now we prove that any rules $\{ r_j \}$ (state transitions)
  generated by a synthesis step ($\hookrightarrow$) preserve $R$. This is the
  most crucial (hence difficult) step. Letting $\mathcal{I}_{i+1} \triangleq
  \mathcal{I}_i + \{ r_j \}$, we should be able to prove $\mathcal{I}_i
  \sqsubseteq \mathcal{S} \to \mathcal{I}_{i+1} \sqsubseteq \mathcal{S}$, by
  using the fact that the rules $\{ r_j \}$ preserve $R$.
\item The fixpoint: we keep executing synthesis steps until it generates no more
  rules. By (1) and (2), we finally show $\mathcal{I}_\infty \sqsubseteq
  \mathcal{S}$, where $\mathcal{I}_\infty$ is the final synthesized system.
\end{enumerate}

\end{document}

